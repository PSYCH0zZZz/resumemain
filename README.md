# PSYCH0zZZz
This repio for my resume. I placed some C programms C03-C13.

C03-C13 derictories with some functions and examples of sorts, trees, list etc.


BSQ - BSQ is a file parser, my program will receive one or more files, which are maps, in these maps, you will have to find the biggest square. We made our best so our BSQ can go as quick as possible.

dzfibbon3 - fibbonachi founder

dz1 - in this task i searched for the roots of the equation


=============exam directory=================

mp1:

    An array of data about the employees of the military regiment: full name, rank, company number, age (comparison by fields - rank, full name, company number)
    
1) Implement in C++ sorting for an array of objects in
according to option.

2) Overload comparison operators (>, <, >=, <=) for comparison
objects.

3) The input data for sorting the array must be read from
external sources: text file, MS Excel file, MS Access,
data from the DBMS (any one to choose from).

4) Select 7-10 datasets for sorting dimension from 100 and
more (but not less than 100,000). Detect (programmatically) the sorting time of each algorithm. Based on the points obtained, plot graphs of sorting time versus array dimension for each of the sorting algorithms on one coordinate axis. Make a conclusion about which method is better to use in which case.

sorting:

a) Selection sort

c) Sorting by simple insertions

e) Heap sort

An array of data about the employees of the military regiment: full name, rank, company number, age (comparison by fields - rank, full name, company number)


mp2:

1) Implement direct and binary search for a given element in an array of objects by key in accordance with the variant (the key is the first non-numeric field of the object).


2) The input data for the search must be read from external sources: text file, MS Excel file, MS Access, data from the DBMS (any choice).


3) Search 7-10 times on arrays of different dimensions from 100 or more (but not less than 100000). Time the search (programmatically) for the following methods: direct search, binary search in a pre-sorted array, array sorting (the most efficient method from work 2) and binary search in it. Based on the obtained points, construct graphs of the dependence of the search time on the dimension of the array.


4) Write the input data to the multimap<key, object> associative array and compare the search time for the key in it with the search time from step 3. Add search time data in an associative array to a general comparison with other methods and build a graph of search time versus array dimension.


5) Make a report containing a title page, program code with specifications of each method and detailed comments, graphs of search speeds and conclusions.

mp3:

1) Come up with a “simple” (without going too far into the probability of collisions) and “complex” (more efficient in speed and with fewer collisions) hash functions for calculating the hash of the key field of your version (of your class).


2) Add a field with a hash value to the class, change the constructors and methods accordingly.


3) Build a hash table based on the hash value and write a function to search for an element in an array of objects using a hash table, implement one of the collision resolution methods.


4) Conduct experiments to study the dependence of the search time on the array dimension for both hash functions, build graphs, draw conclusions.


5) Compare the obtained results with the search time results obtained in the previous work.


6) Investigate the dependence of the number of collisions for each hash function on the array dimension, build a graph.

Also you can check my GitLab repo.
https://gitlab.com/PSYCH0zZZz/psycho/-/tree/main
